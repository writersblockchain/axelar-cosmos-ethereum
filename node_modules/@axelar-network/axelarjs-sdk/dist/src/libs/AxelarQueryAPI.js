"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AxelarQueryAPI = void 0;
const utils_1 = require("ethers/lib/utils");
const assets_1 = require("../assets");
const constants_1 = require("../constants");
const services_1 = require("../services");
const contract_1 = require("./TransactionRecoveryApi/constants/contract");
const AxelarQueryClient_1 = require("./AxelarQueryClient");
class AxelarQueryAPI {
    constructor(config) {
        const { axelarLcdUrl, axelarRpcUrl, environment } = config;
        const links = (0, constants_1.getConfigs)(environment);
        this.axelarRpcUrl = axelarRpcUrl || links.axelarRpcUrl;
        this.axelarLcdUrl = axelarLcdUrl || links.axelarLcdUrl;
        this.axelarGMPServiceUrl = links.axelarGMPApiUrl;
        this.environment = environment;
        this.lcdApi = new services_1.RestService(this.axelarLcdUrl);
        this.rpcApi = new services_1.RestService(this.axelarRpcUrl);
        this.axelarGMPServiceApi = new services_1.RestService(this.axelarGMPServiceUrl);
        this._initializeAssets();
    }
    _initializeAssets() {
        return __awaiter(this, void 0, void 0, function* () {
            this.allAssets = yield (0, assets_1.loadAssets)({ environment: this.environment });
        });
    }
    /**
     * Gets the fee for a chain and asset
     * example testnet query: https://axelartest-lcd.quickapi.com/axelar/nexus/v1beta1/fee?chain=ethereum&asset=uusd
     * @param chainName
     * @param assetDenom
     * @returns
     */
    getFeeForChainAndAsset(chainName, assetDenom) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.axelarQueryClient)
                    this.axelarQueryClient = yield AxelarQueryClient_1.AxelarQueryClient.initOrGetAxelarQueryClient({
                        environment: this.environment,
                        axelarRpcUrl: this.axelarRpcUrl,
                    });
                return yield this.axelarQueryClient.nexus.FeeInfo({ chain: chainName, asset: assetDenom });
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Gest the transfer fee for a given transaction
     * example testnet query: "https://axelartest-lcd.quickapi.com/axelar/nexus/v1beta1/transfer_fee?source_chain=ethereum&destination_chain=terra&amount=100000000uusd"
     * @param sourceChainName
     * @param destinationChainName
     * @param assetDenom
     * @param amountInDenom
     * @returns
     */
    getTransferFee(sourceChainName, destinationChainName, assetDenom, amountInDenom) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.axelarQueryClient)
                    this.axelarQueryClient = yield AxelarQueryClient_1.AxelarQueryClient.initOrGetAxelarQueryClient({
                        environment: this.environment,
                        axelarRpcUrl: this.axelarRpcUrl,
                    });
                return yield this.axelarQueryClient.nexus.TransferFee({
                    sourceChain: sourceChainName,
                    destinationChain: destinationChainName,
                    amount: `${amountInDenom.toString()}${assetDenom}`,
                });
            }
            catch (e) {
                throw e;
            }
        });
    }
    /**
     * Gets the gas price for a destination chain to be paid to the gas receiver on a source chain
     * example testnet query: https://testnet.api.gmp.axelarscan.io/?method=getGasPrice&destinationChain=ethereum&sourceChain=avalanche&sourceTokenAddress=0x43F4600b552089655645f8c16D86A5a9Fa296bc3&sourceTokenSymbol=UST
     * @param sourceChainName
     * @param destinationChainName
     * @param sourceChainTokenSymbol
     * @returns
     */
    getGasInfo(sourceChainName, destinationChainName, sourceChainTokenSymbol) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = new URLSearchParams({
                method: "getGasPrice",
                destinationChain: destinationChainName,
                sourceChain: sourceChainName,
                sourceTokenSymbol: sourceChainTokenSymbol,
            });
            return this.axelarGMPServiceApi.get(`?${params}`).then((resp) => resp.result);
        });
    }
    /**
     * Gets the base fee in native token wei for a given source and destination chain combination
     * @param sourceChainName
     * @param destinationChainName
     * @param sourceTokenSymbol (optional)
     * @returns base fee in native token in wei, translated into the native gas token of choice
     */
    getNativeGasBaseFee(sourceChainName, destinationChainName, sourceTokenSymbol) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.axelarGMPServiceApi
                .post("", {
                method: "getFees",
                destinationChain: destinationChainName,
                sourceChain: sourceChainName,
                sourceTokenSymbol,
            })
                .then((response) => {
                const { base_fee, source_token } = response.result;
                const { decimals } = source_token;
                const baseFee = (0, utils_1.parseUnits)(base_fee.toString(), decimals).toString();
                return { baseFee, sourceToken: source_token, success: true };
            })
                .catch((error) => ({ success: false, error: error.message }));
        });
    }
    /**
     * Calculate estimated gas amount to pay for the gas receiver contract.
     * @param sourceChainName
     * @param destinationChainName
     * @param sourceChainTokenSymbol
     * @param gasLimit (Optional) An estimated gas amount required to execute `executeWithToken` function. The default value is 700000 which should be sufficient for most transactions.
     * @param gasMultiplier (Optional) A multiplier used to create a buffer above the calculated gas fee, to account for potential slippage throughout tx execution, e.g. 1.1 = 10% buffer. supports up to 3 decimal places
     * @returns
     */
    estimateGasFee(sourceChainName, destinationChainName, sourceChainTokenSymbol, gasLimit = contract_1.DEFAULT_ESTIMATED_GAS, gasMultiplier = 1.1) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getNativeGasBaseFee(sourceChainName, destinationChainName, sourceChainTokenSymbol).catch(() => undefined);
            if (!response)
                return "0";
            const { baseFee, sourceToken, success } = response;
            if (!success || !baseFee || !sourceToken)
                return "0";
            const { gas_price } = sourceToken;
            const destTxFee = (0, utils_1.parseEther)(gas_price).mul(gasLimit);
            if (gasMultiplier > 1) {
                return destTxFee
                    .add(baseFee)
                    .mul(gasMultiplier * 10000)
                    .div(10000)
                    .toString();
            }
            return destTxFee.add(baseFee).toString();
        });
    }
    /**
     * Get the denom for an asset given its symbol on a chain
     * @param symbol
     * @param chainName
     * @returns
     */
    getDenomFromSymbol(symbol, chainName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.allAssets)
                yield this._initializeAssets();
            const assetConfig = this.allAssets.find((assetConfig) => { var _a; return ((_a = assetConfig.chain_aliases[chainName]) === null || _a === void 0 ? void 0 : _a.assetSymbol) === symbol; });
            if (!assetConfig)
                return null;
            return assetConfig === null || assetConfig === void 0 ? void 0 : assetConfig.common_key[this.environment];
        });
    }
    /**
     * Get the symbol for an asset on a given chain given its denom
     * @param denom
     * @param chainName
     * @returns
     */
    getSymbolFromDenom(denom, chainName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.allAssets)
                yield this._initializeAssets();
            const assetConfig = this.allAssets.find((assetConfig) => assetConfig.common_key[this.environment] === denom);
            if (!assetConfig)
                return null;
            return assetConfig.chain_aliases[chainName].assetSymbol;
        });
    }
    /**
     * Get the asset config for an asset on a given chain given its denom
     * @param denom
     * @param chainName
     * @returns
     */
    getAssetConfigFromDenom(denom, chainName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.allAssets)
                yield this._initializeAssets();
            const assetConfig = this.allAssets.find((assetConfig) => assetConfig.common_key[this.environment] === denom);
            if (!assetConfig)
                return null;
            const result = assetConfig.chain_aliases[chainName];
            if (!result)
                return null;
            result.decimals = assetConfig.decimals;
            result.common_key = assetConfig.common_key[this.environment];
            return result;
        });
    }
}
exports.AxelarQueryAPI = AxelarQueryAPI;
//# sourceMappingURL=AxelarQueryAPI.js.map